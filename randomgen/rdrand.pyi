from threading import Lock
from types import TracebackType
from typing import Dict, Optional, Type, Union

import numpy as np

from randomgen.common import BitGenerator

class RaisingLock:
    lock: Lock
    def acquire(self, blocking: bool = True, timeout: int = -1) -> None: ...
    def release(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(
        self,
        type: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...

class RDRAND(BitGenerator):
    def __init__(self, seed: None = None, *, retries: int = 10) -> None: ...
    @property
    def success(self) -> bool: ...
    def seed(self, seed: None = None) -> None: ...
    def random_raw(
        self, size: Optional[int] = None, output: bool = True
    ) -> Union[None, int, np.ndarray]: ...
    def jumped(self, iter: int = 1) -> RDRAND: ...
    @property
    def state(self) -> Dict[str, Union[str, int, np.ndarray]]: ...
    @state.setter
    def state(self, value: Dict[str, Union[str, int, np.ndarray]]) -> None: ...
