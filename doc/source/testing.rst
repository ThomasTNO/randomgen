=================
Quality Assurance
=================

A values below are the maximum output size where a bit generator or sequence of bit generators
has passed PractRand_. A -- indicates that configuration is not relevant. Failures are marked
with FAIL. Most bit generators were only tested in their default configuration.
Non-default configurations are indicated by listing the keyword arguments to the bit generator.
Two sets of tests were performed. The first tested all configurations using 128GB of data using
PractRand's extended set of tests and additional bit folding. The second set of tests used
4TB of data wit the standard set of tests and folding.

All bit generators have been tested using the same :class:`~numpy.random.SeedSequence`
initialized with the same 256-bits of entropy taken from random.org.

.. include:: test-results.txt

Notes
-----
¹ Failures at or before 128GB were generated by tests that used the expanded
set of tests and extra bt folds (``-te 1`` and ``-tf 2``). Failures at sample
sizes above 128GB were produces using the default configuration
(``-te 0`` and ``-tf 0``).

² PCG64DXSM and PCG64(variant=dxsm) are identical and so the latter not separately reported.

³ SFC64(k=weyl) uses distinct Weyl increments that have 50% or fewer non-zero bits.

⁴ The Mersenne Twisters begin to fail at 64GB.  This is a known limitation of MT-family
generators. These should not be used in large studies except when backward compatibility
is required.

⁵ Identical output to the version included in NumPy 1.19.

.. _PractRand: http://pracrand.sourceforge.net/

Example Configuration
---------------------
All configurations are constructed using the same template. The code below tests a
configuration using 8,196 streams of :class:`~randomgen.aes.AESCounter`. The other
configurations simply make changes to either ``JUMPED`` or ``STREAMS``.

::

   import numpy as np

   import randomgen as rg

   ENTROPY = 86316980830225721106033794313786972513572058861498566720023788662568817403978
   JUMPED = False
   STREAMS = 8196
   BIT_GENERATOR_KWARGS = {}

   SEED_SEQ = np.random.SeedSequence(ENTROPY)


   BASE_GEN = rg.AESCounter(SEED_SEQ, **BIT_GENERATOR_KWARGS)
   if STREAMS == 1:
      bit_gens = [BASE_GEN]
   elif JUMPED:
      bit_gens = [BASE_GEN]
      for _ in range(STREAMS - 1):
         bit_gens.append(bit_gens[-1].jumped())
   else:
      bit_gens = []
      for child in SEED_SEQ.spawn(STREAMS):
         bit_gens.append(rg.AESCounter(child, **BIT_GENERATOR_KWARGS))
   output = 64
